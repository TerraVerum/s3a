from typing import Optional, Callable, Dict, Union, Type

import numpy as np
import pyqtgraph as pg
from pyqtgraph.Qt import QtCore, QtWidgets, QtGui
import cv2 as cv

from s3a import ComplexXYVertices
from s3a.constants import FR_CONSTS
from s3a.structures import FRParam
from s3a.structures import XYVertices

__all__ = ['RectROI', 'PaintFillROI', 'PolygonROI', 'SHAPE_ROI_MAPPING',
           'ExtendedROI']

from s3a.views.clickables import BoundScatterPlot

def _clearPoints(roi: pg.ROI):
  while roi.handles:
    roi.removeHandle(0)

class ROIExtension:
  """
  Collection of overloaded rois that know how to update themseleves as needed within
  the annotator regions
  """
  connected = True
  shadowPen: Optional[QtGui.QPen] = pg.mkBrush(0, 0, 0, 100, width=2)

  def updateShape(self, ev: QtGui.QMouseEvent, xyEvCoords: XYVertices) -> (bool, Optional[XYVertices]):
    """
    Customized update for the ROI.

    :param ev: Mouse event (press, release, move, etc.)
    :param xyEvCoords: Location of the event relative to the imgItem

    :return: Tuple (constructingRoi, verts):
              * `constructingRoi`: Whether the ROI is currently under construction
              *  `verts`: Vertices generated by this ROI. If the ROI is not done,
                 `None` is returned instead.
    """

  @property
  def vertices(self): return XYVertices()

  def clear(self: pg.ROI):
    while self.handles:
      # TODO: Submit bug request in pyqtgraph. removeHandle of ROI takes handle or
      #  integer index, removeHandle of PolyLine requires handle object. So,
      #  even though PolyLine should be able  to handle remove by index, it can't
      self.removeHandle(self.handles[0]['item'])

class ExtendedROI(ROIExtension, pg.ROI):
  """
  Purely for specifying the interface provided by the following classes. This is mainly
  so PyCharm knows what methds and signatures are provided by the ROIs below.
  """


class RectROI(ROIExtension, pg.RectROI):
  connected = True

  def __init__(self):
    super().__init__([-1,-1], [0,0], invertible=True)

  def updateShape(self, ev: QtGui.QMouseEvent, xyEvCoords: XYVertices) -> (
      bool, Optional[XYVertices]):
    """
    See function signature for :func:`ExtendedROI.updateShape`
    """
    success = True
    verts = None
    constructingRoi = False
    # If not left click, do nothing
    if (int(ev.buttons()) & QtCore.Qt.LeftButton) == 0 \
       and ev.button() != QtCore.Qt.LeftButton:
      return constructingRoi, verts

    evType = ev.type()
    if evType == QtCore.QEvent.MouseButtonPress:
      # Need to start a new shape
      self.setPos(xyEvCoords.asPoint())
      self.setSize(0)
      self.addScaleHandle([1, 1], [0, 0])
      constructingRoi = True
    elif evType == QtCore.QEvent.MouseMove:
      # ROI handle will change the shape as needed, no action required
      constructingRoi = True
    elif evType == QtCore.QEvent.MouseButtonRelease:
      # Done drawing the ROI, complete shape, get vertices
      verts = self.vertices
      constructingRoi = False
    else:
      success = False
      # Unable to process this event

    if success:
      ev.accept()

    return constructingRoi, verts

  @property
  def vertices(self) -> XYVertices:
    origin = np.array([self.pos()])
    sz = np.array([self.size()])
    # Sz will be negative at inverted shape dimensions

    # Outer contours generated by opencv are counterclockwise. Replicate this structure
    # for consistency
    otherCorners = [sz * [0, 1], sz * [1, 1], sz * [1, 0]]

    verts_np = np.vstack([origin, *(origin + otherCorners)])

    # This happens when user clicks -- all verts are in the same spot
    if np.all(verts_np[0,:] == verts_np[1,:]):
      verts_np = verts_np[[0]]
    verts = XYVertices(verts_np, connected=self.connected, dtype=float)
    return verts

class EllipseROI(ROIExtension, pg.EllipseROI):
  connected = True
  constructingROI = False

  def __init__(self, *args, **kwargs):
    super().__init__([0,0], [1,1], invertible=True, **kwargs)

  def paint(self, p, opt, widget):
    try:
      super().paint(p, opt, widget)
    except ZeroDivisionError:
      return

  @property
  def vertices(self):
    br = self.boundingRect()
    if not br:
      # point selection intsead of full shape
      return XYVertices([[*self.pos()]])
    w_h = np.array([br.height(), br.width()])
    mask = self.renderShapeMask(*(w_h+2)) > 0
    offsetVerts = ComplexXYVertices.fromBwMask(mask).stack() + [*self.pos()]
    # If shape is inverted, must be offset even more to put verts in the right place
    invertedOffset = np.clip(np.array([br.x(), br.y()]), -np.inf, 0)
    return (offsetVerts + invertedOffset).astype(int)


  def updateShape(self, ev: QtGui.QMouseEvent, xyEvCoords: XYVertices) -> (
      bool, Optional[XYVertices]):
    """
    See function signature for :func:`ExtendedROI.updateShape`
    """
    success = True
    verts = None
    constructingRoi = False
    # If not left click, do nothing
    if (int(ev.buttons()) & QtCore.Qt.LeftButton) == 0 \
        and ev.button() != QtCore.Qt.LeftButton:
      return constructingRoi, verts

    evType = ev.type()
    if evType == QtCore.QEvent.MouseButtonPress:
      # Need to start a new shape
      self.setPos(xyEvCoords.asPoint())
      self.setSize(0)
      self.addScaleHandle([1, 1], [0, 0])
      constructingRoi = True
    elif evType == QtCore.QEvent.MouseMove:
      # ROI handle will change the shape as needed, no action required
      constructingRoi = True
    elif evType == QtCore.QEvent.MouseButtonRelease:
      # Done drawing the ROI, complete shape, get vertices
      verts = self.vertices
      constructingRoi = False
    else:
      success = False
      # Unable to process this event

    if success:
      ev.accept()

    return constructingRoi, verts


class PolygonROI(ROIExtension, pg.PolyLineROI):
  connected = True
  constructingRoi = False

  def __init__(self, *args, **kwargs):
    # Since this won't execute until after module import, it doesn't cause
    # a dependency
    super().__init__([], closed=False, movable=False, removable=False, *args, **kwargs)
    # Force new menu options
    self.finishPolyAct = QtWidgets.QAction()

  def updateShape(self, ev: QtGui.QMouseEvent, xyEvCoords: XYVertices) -> (
      bool, Optional[XYVertices]):
    """
    See function signature for :func:`ExtendedROI.updateShape`
    """
    success = True
    verts = None
    evType = ev.type()
    if evType == QtCore.QEvent.MouseButtonPress:
      # Start a new shape if this is the first press, or create a new handle of an existing shape
      if not self.constructingRoi:
        # ROI is new
        self.setPos(xyEvCoords.asPoint())
        self.setPoints([])
      self.addVertex(xyEvCoords)
      self.constructingRoi = True
    elif evType == QtCore.QEvent.MouseMove:
      # ROI handle will change the shape as needed, no action required
      pass
    elif evType in [QtCore.QEvent.MouseButtonRelease, QtCore.QEvent.MouseButtonDblClick]:
      # Check if the placed point is close enough to the first vertex. If so, the shape is done
      vertsToCheck = self.vertices
      if ((len(vertsToCheck) > 2)
          and (evType == QtCore.QEvent.MouseButtonDblClick
            or np.all(np.abs(vertsToCheck[0] - vertsToCheck[-1]) < 5)
          )
      ):
        verts = vertsToCheck
        self.constructingRoi = False
      else:
        # Not done constructing shape, indicate this by clearing the returned list
        pass
    else:
      success = False
      # Unable to process this event

    if success:
      ev.accept()

    return self.constructingRoi, verts

  def addVertex(self, xyEvCoords: XYVertices):
    """
    Creates a new vertex for the polygon
    :param xyEvCoords: Location for the new vertex
    :return: Whether this vertex finishes the polygon
    """
    # Account for moved ROI
    xyEvCoords.x = (xyEvCoords.x - self.x())
    xyEvCoords.y = (xyEvCoords.y - self.y())
    # If enough points exist and new point is 'close' to origin,
    # consider the ROI complete
    newVert = QtCore.QPointF(xyEvCoords.x, xyEvCoords.y)
    self.addFreeHandle(newVert)
    if len(self.handles) > 1:
      self.addSegment(self.handles[-2]['item'], self.handles[-1]['item'])

  @property
  def vertices(self):
    origin = np.array(self.pos())
    if len(self.handles) > 0:
      verts_np = np.array([(h['pos'].x(), h['pos'].y()) for h in self.handles]) + origin
      return XYVertices(verts_np, connected=self.connected, dtype=float)
    else:
      return XYVertices(connected=self.connected, dtype=float)

class PaintFillROI(PolygonROI):

  connected = False

  def updateShape(self, ev: QtGui.QMouseEvent, xyEvCoords: XYVertices) -> (
      bool, Optional[XYVertices]):
    """
    See function signature for :func:`ExtendedROI.updateShape`
    """
    success = True
    verts = None
    evType = ev.type()
    # If not left click, do nothing
    if (int(ev.buttons()) & QtCore.Qt.LeftButton) == 0:
      self.constructingRoi = False
      self.setPoints([])
      return self.constructingRoi, verts

    if (evType == ev.MouseButtonPress) | (evType == ev.MouseMove):
      # Started / doing floodfill
      if not self.constructingRoi:
        # Just started. Add a visible point for eye candy
        self.addVertex(xyEvCoords)
      verts = xyEvCoords
      self.constructingRoi = True
    # No occurrence of mouse release, since that would violate the 'if' check for
    # button press
    else:
      success = False

    if success:
      ev.accept()
    return self.constructingRoi, verts

SHAPE_ROI_MAPPING: Dict[FRParam, Callable[[], ExtendedROI]] = {
  FR_CONSTS.DRAW_SHAPE_PAINT: PaintFillROI,
  FR_CONSTS.DRAW_SHAPE_RECT: RectROI,
  FR_CONSTS.DRAW_SHAPE_POLY: PolygonROI,
  FR_CONSTS.DRAW_SHAPE_ELLIPSE: EllipseROI,
}

def addShadowToPaint(roi: Type[ExtendedROI]):
  oldPaint = roi.paint
  def newPaint(self: ExtendedROI, p, opt, widget):
    if self.shadowPen not in [None, QtCore.Qt.NoPen]:
      prevPen = self.pen
      p.setBrush(self.shadowPen)
    oldPaint(self, p, opt, widget)
      # self.setPen(prevPen)
    # oldPaint(self, p, opt, widget)

  oldBoundingRect = roi.boundingRect
  def newBR(self: ExtendedROI):
    br = oldBoundingRect(self)
    # Logic adapted for invertible shapes and resizable handles from
    # https://groups.google.com/g/pyqtgraph/c/tWtjJOQF5x4/m/CnQF6IgmDAAJ
    penAdjust = self.pen.width()*0.5
    handleAdjust = self.handleSize
    whAdjust = np.tile(penAdjust+handleAdjust, 2)
    xyAdjust = whAdjust.copy()

    x_y = np.array([br.x(), br.y()])
    w_h = np.array([br.width(), br.height()])

    # Account for 'backwards' shape
    inversion = np.sign(x_y)
    xyAdjust *= inversion

    newBr = QtCore.QRectF(*(x_y + xyAdjust), *(w_h + whAdjust))
    return newBr
  # roi.boundingRect = newBR
  roi.paint = newPaint

for shape in SHAPE_ROI_MAPPING.values():
  addShadowToPaint(shape)

# Adapted from https://groups.google.com/forum/#!msg/pyqtgraph/tWtjJOQF5x4/CnQF6IgmDAAJ
# def boundingRect(_roi: pg.ROI):
#   pw = 0.5 * _roi.currentPen.width()
#   return QtCore.QRectF(-0.5 * pw, -0.5 * pw, pw + _roi.state['size'][0], pw + _roi.state['size'][1]).normalized()
#
# for roi in SHAPE_ROI_MAPPING.values():
#   roi.boundingRect = boundingRect
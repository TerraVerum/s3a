from typing import Optional

import pyqtgraph as pg
from pyqtgraph.Qt import QtCore, QtWidgets, QtGui
from pyqtgraph import ROI, PolyLineROI, RectROI, LineSegmentROI
import numpy as np

from Annotator.exceptions import FRInvalidROIEvType
from Annotator.params import FRVertices

def _getImgMask(roi: pg.ROI, imgItem: pg.ImageItem):
  imgMask = np.zeros(imgItem.image.shape[0:2], dtype='bool')
  roiSlices, _ = roi.getArraySlice(imgMask, imgItem)
  # TODO: Clip regions that extend beyond image dimensions
  roiSz = [curslice.stop - curslice.start for curslice in roiSlices]
  # renderShapeMask takes width, height args. roiSlices has row/col sizes,
  # so switch this order when passing to renderShapeMask
  roiSz = roiSz[::-1]
  roiMask = roi.renderShapeMask(*roiSz).astype('uint8')
  # Also, the return value for renderShapeMask is given in col-major form.
  # Transpose this, since all other data is in row-major.
  roiMask = roiMask.T
  imgMask[roiSlices[0], roiSlices[1]] = roiMask
  return imgMask

def _clearPoints(roi: pg.ROI):
  while roi.handles:
    roi.removeHandle(0)

# --------
# COLLECTION OF OVERLOADED ROIS THAT KNOW HOW TO UPDATE THEMSELEVES AS NEEDED WITHIN
# THE ANNOTATOR REGIONS
# --------
class FRExtendedROI(pg.ROI):
  """
  Purely for specifying the interface provided by the following classes. This is mainly
  so PyCharm knows what methds and signatures are provided by the ROIs below.
  """
  connected: bool

  def updateShape(self, ev: QtGui.QMouseEvent, xyEvCoords: np.ndarray) -> (bool, Optional[FRVertices]): pass

class FRRectROI(pg.RectROI):
  connected = True

  def updateShape(self, ev: QtGui.QMouseEvent, xyEvCoords: np.ndarray) -> (
      bool, Optional[FRVertices]):
    """
    Customized update for the FRROI.

    :param ev: Mouse event (press, release, move, etc.)
    :param xyEvCoords: Location of the event relative to the image

    :return: Tuple (success, verts):
              * `constructingRoi`: Whether the ROI is currently under construction
              *  `verts`: Vertices generated by this ROI. If the ROI is not done,
              `None` is returned instead.
    """
    success = True
    verts = None
    constructingRoi = False
    # If not left click, do nothing
    if (int(ev.buttons()) & QtCore.Qt.LeftButton) == 0:
      return constructingRoi, verts

    evType = ev.type()
    if evType == QtCore.QEvent.MouseButtonPress:
      # Need to start a new shape
      self.setPos(xyEvCoords)
      self.setSize(0)
      self.addScaleHandle([1, 1], [0, 0])
      constructingRoi = True
    elif evType == QtCore.QEvent.MouseMove:
      # ROI handle will change the shape as needed, no action required
      constructingRoi = True
    elif evType == QtCore.QEvent.MouseButtonRelease:
      # Done drawing the ROI, complete shape, get vertices
      verts_list = [[tup[1].x(), tup[1].y()] for tup in self.getSceneHandlePositions()]
      verts = FRVertices.createFromArr(verts_list)
      constructingRoi = False
    else:
      success = False
      # Unable to process this event

    if success:
      ev.accept()

    return constructingRoi, verts